#FLATLAND WARS
#Aryan Nehete
#Create a game with pygame with a triangle targeting a circle

import pygame as pg
import random
import math

#pygame intialize
pg.init()
clock = pg.time.Clock()

#screen
screen = pg.display.set_mode((900, 900))
pg.display.set_caption("really hard game :(")

#triangle variables
tAngle = random.randint(0, 360) #angle of triangle
triangleX = random.randint(150, 750) #x position of "origin" of triangle
triangleY = random.randint(150, 750) #y position of "origin" of triangle
size = 40 #length from "origin" to point 1 of triangle

#circle variables
radius = 10 #radius of circle
cAngle = random.randint(0, 360) #direction the circle is travelling
circleX = random.randint(50, 850) #x position of circle center
circleY = random.randint(50, 850) #y position of circle center

#variables
streak = 0
font = pg.font.Font('freesansbold.ttf', 30)
scores = []
boost = False
run = True
ended = False
frame = 0
easy = False

#function to generate points of a triangle
def pointGenerate(x, y, angle, dx, dy, size):
    #x - x position of "origin" of triangle
    #y - y position of "origin" of triangle
    #angle - angle which the triangle is pointing
    #dx - difference in x value from "origin" of triangle to point 1
    #dy - difference in y value from "origin" of triangle to point 1
    #size - length from "origin" to point 1

    #find distance to point 2
    angle2 = angle + 150
    #dx is difference in x value from "origin" of triangle
    dx2 = size*math.cos(math.radians(angle2))
    #dy is difference in y value from "origin" of triangle
    dy2 = size*math.sin(math.radians(angle2))

    #same thing
    angle3 = angle - 150
    dx3 = size*math.cos(math.radians(angle3))
    dy3 = size*math.sin(math.radians(angle3))

    if easy: pg.draw.line(screen, (0,255,0), (x+100*dx, y+100*dy), (x, y)) #aim line

    #return list of three points
    points = [(x+dx,y+dy), (x+dx2, y+dy2), (x+dx3,y+dy3)]

    return points

#reset all variables
def reset():
    #use global to change their global values instead of local
    global tAngle
    global triangleX
    global triangleY
    global size
    global radius
    global cAngle
    global circleX
    global circleY
    global boost

    tAngle = random.randint(0, 360) #angle of triangle
    triangleX = random.randint(150, 750) #x position of "origin" of triangle
    triangleY = random.randint(150, 750) #y position of "origin" of triangle
    size = 15 #length from "origin" to point 1 of triangle

    #circle variables
    radius = 10 #radius of circle
    cAngle = random.randint(0, 360) #direction the circle is travelling
    circleX = random.randint(50, 850) #x position of circle center
    circleY = random.randint(50, 850) #y position of circle center

    boost = False

#restart game
def restart():
    #use global to change their global values instead of local
    global boost
    global ended
    global frame
    global streak
    global font
    global scores

    boost = False
    ended = False
    frame = 0

    streak = 0
    font = pg.font.Font('freesansbold.ttf', 30)
    scores = []

#function to draw triangle
def triangle(points):
    #points - list of three points generated by "points" function
    pg.draw.polygon(screen, (0,255,0), points)

#function to draw circle
def circle(x, y, r):
    #x - x position of circle center
    #y - y position of circle center
    #r - radius of circle
    pg.draw.circle(screen, (255,0,0), (x, y), r) 

#function to check if triangle is colliding with circle
def collide(cx, cy, points):
    #cx - x position of circle center
    #cy - y position of circle center
    #points - list of three points generated by "points" function

    for i in points: #loop through all points of triangle
        x = i[0] #x - x position of point of triangle
        y = i[1] #y - y position of point of triangle
        
        a = abs(cx - x) #leg a of triangle formed by circle center and triangle point
        b = abs(cy - y) #leg b of triangle formed by circle center and triangle point

        if a*a+b*b <= radius**2: return True #if point is in range of the circle
     
    return False

#function to print streak
def printStreak(st):
    #print the streak
    text = font.render("Score: "+str(st), True, (255, 255, 255), None)
    textRect = text.get_rect()
    textRect.center = 800, 100
    screen.blit(text, textRect)

    #print instrucitons
    text = font.render("Press e to toggle aim line", True, (255, 255, 255), None)
    textRect = text.get_rect()
    textRect.center = 200, 100
    screen.blit(text, textRect)

#function to end game 
def end(streak):
    global run #change the global variable to end game
    global scores

    #read codenames and scores
    file = open("highscores.txt", 'r')
    for line in file:
        reading = line.strip().split()
        scores.append([reading[0], int(reading[1])])
    
    #if streak is in top 5
    if streak > scores[4][1]:
        code = ""
        while len(code) != 3: #get 3 letter code name
            code = input("Please input a 3-letter code name: ")
        scores.append([code, streak]) #add to scores
    
    scores.sort(key=lambda x:x[1], reverse=True) #sort scores in order
    file.close()

    #write top 5 scores
    file = open("highscores.txt", 'w')
    for i in range(5):
        file.write(' '.join(str(scores[i][j]) for j in range(2)) + '\n')
    file.close()

#function to print leaderboard
def leaderboard(scores):
    for i in range(7): #in range 7 to show only top 5 spots + title + instruction
        if 0 < i < 6: scoreString = (' '.join(str(scores[i-1][j]) for j in range(2)))
        elif i == 6: scoreString = "Press n to play again" #if last line
        elif i == 0: scoreString = "Highscores:" #if first line
        #print text
        text = font.render(str(scoreString), True, (255, 255, 255), None)
        textRect = text.get_rect()
        textRect.center = 450, 390 + 40*i
        screen.blit(text, textRect)

while run:
    clock.tick(120)
    frame += 1
    screen.fill((0, 0, 0))
    
    #check if arrow keys or a or d is pressed and adjust triangle angle accordingly
    keys = pg.key.get_pressed()
    if (keys[pg.K_LEFT] or keys[pg.K_a]) and not boost and not ended:
        tAngle -= 1.5
    if (keys[pg.K_RIGHT] or keys[pg.K_d]) and not boost and not ended:
        tAngle += 1.5

    #check if space key is pressed to boost or if "x" is pressed to close window
    for event in pg.event.get():
        if event.type == pg.QUIT:
            run = False
        if event.type == pg.KEYDOWN:
            if event.key == pg.K_SPACE and not ended:
                boost = True
            if event.key == pg.K_n:
                reset()
                restart()
            if event.key == pg.K_e:
                easy = not easy

    tdx = size*math.cos(math.radians(tAngle)) #tdx is difference in x value from "origin" of triangle to point 1
    tdy = size*math.sin(math.radians(tAngle)) #tdy is difference in y value from "origin" of triangle to point 1
    cdx = math.cos(math.radians(cAngle)) #cdx is "run" of line with cAngle
    cdy = math.sin(math.radians(cAngle)) #cdy is "rise" of line with cAngle

    #move circle
    circleX += 1*cdx 
    circleY += 1*cdy
    if frame%30 == 0: radius = max(radius*0.99, 1)

    #change circle angle to positive equivalent 
    if cAngle < 0: cAngle = -(360 - cAngle)
    
    #if circle hits edges then bounce off
    if circleX <= radius or circleX >= (900-radius):
        cAngle = 180 - cAngle
    if circleY <= radius or circleY >= (900-radius):
        cAngle = 90 + (180 - (cAngle - 90))
    
    #move triangle if boost is True
    if boost:
        triangleX += tdx/4
        triangleY += tdy/4
    
    points = pointGenerate(triangleX, triangleY, tAngle, tdx, tdy, size) #create list of triangles three points

    #if it collides add a point
    if collide(circleX, circleY, points):
        streak += 1
        reset()
    
    #if it hits edge end game
    if (points[0][0] > 900 or points[0][0] < 0 or points[0][1] > 900 or points[0][1] < 0) and not ended:
        boost = False
        ended = True
        end(streak)
    
    if ended: leaderboard(scores) #display leaderboard if game ended

    #draw triangle and circle and streak counter
    triangle(points)
    circle(circleX, circleY, radius)
    printStreak(streak)

    pg.display.update()

pg.quit()
